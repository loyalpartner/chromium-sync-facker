// Code generated by protoc-gen-go. DO NOT EDIT.
// source: components/sync/protocol/webauthn_credential_specifics.proto

package sync_pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// WebauthnCredentialSpecifics is an entity that backs a WebAuthn
// PublicKeyCredential. Since it contains the authenticator’s view of this
// object, it has a private key rather than a public key.
// (https://www.w3.org/TR/webauthn-2/#iface-pkcredential).
//
// Names of fields are taken from WebAuthn where possible. E.g.
// user.displayName in WebAuthn becomes user_display_name here.
//
// All fields are immutable after creation except for user_display_name, which
// may be updated by a user.
type WebauthnCredentialSpecifics struct {
	// Sync's ID for this entity (sometimes called the client unique tag), 16
	// random bytes. This value is used within Sync to identify this entity. The
	// credential ID is not used because the (hashed) sync_id is exposed to the
	// Sync server, and we don’t want Google to be able to map a credential ID to
	// an account. Password entities construct this value from the concatenation
	// of many fields and depend on the fact that the server only sees a hash of
	// it. But the only high-entropy secret here is the private key, which will
	// have different encryption in the future, and private keys are not the sort
	// of data to copy into other fields. Therefore this independent value is
	// provided to form the client's ID.
	SyncId []byte `protobuf:"bytes,1,opt,name=sync_id,json=syncId" json:"sync_id,omitempty"`
	// The credential ID, 16 random bytes. This is a value surfaced in
	// the WebAuthn API (https://www.w3.org/TR/webauthn-2/#credential-id).
	CredentialId []byte `protobuf:"bytes,2,opt,name=credential_id,json=credentialId" json:"credential_id,omitempty"`
	// An RP ID is a WebAuthn concept:
	// https://www.w3.org/TR/webauthn-2/#rp-id. It’s usually a domain name,
	// although in non-Web contexts it can be a URL with a non-Web scheme.
	RpId *string `protobuf:"bytes,3,opt,name=rp_id,json=rpId" json:"rp_id,omitempty"`
	// The user ID, which is also called a “user handle” in WebAuthn
	// (https://www.w3.org/TR/webauthn-2/#user-handle), is an RP-specific
	// identifier that is up to 64-bytes long. An authenticator conceptually only
	// stores a single credential for a given (rp_id, user_id) pair, but there
	// may be several credentials in Sync. They are prioritised using
	// newly_shadowed_credential_ids and creation_time. See below.
	//
	// (We wish to be able to retain several entities for a single (rp_id,
	// user_id) pair because there’s an edge case where we may wish to revert to
	// an older entry and thus need to keep the older entry around in Sync. The
	// revert could happen on a different device too.)
	UserId []byte `protobuf:"bytes,4,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	// The id of credentials with the same (rp_id, user_id) that were
	// shadowed by the creation of this entity.
	//
	// A credential is shadowed if one or more other credentials (from the same
	// account, and with the same (rp_id, user_id)) include its credential_id in
	// their list of shadowed IDs. Shadowed credentials are ignored when finding
	// a credential to sign with. If there is more than one candidate remaining
	// after filtering shadowed credentials then the most recently created (based
	// on creation_time) is used.
	//
	// The reason for all this is that sites can replace a credential by creating
	// another one with the same (rp_id, user_id) pair. However, we don't
	// immediately know whether the WebAuthn response reached the website's
	// server. Consider a user with a poor internet connection. Javascript in the
	// site's origin triggers a credential creation that “overwrites” an existing
	// credential, but the Javascript is unable to send the new public key to the
	// website's server. The user is now locked out: the old credential has been
	// over-written but the website's server doesn't know about the new one.
	//
	// Thus we wish to keep “overwritten” credentials around for a while to allow
	// for some sort of recovery. In the simple case, a new credential shadows
	// the single, previous old credential. We could depend on creation_time, but
	// client clocks aren't always accurate, thus this field.
	//
	// In complicated cases two devices might race to replace a credential, in
	// which case (after mutual syncing) two candidate credentials exist for the
	// same (rp_id, user_id) pair because neither shadows the other. In this case
	// we pick the newest based on |creation_time| but it's quite possible that
	// some recovery will be needed because the website's server thinks the other
	// one is correct.
	//
	// A generation counter isn't used because a single device might replace a
	// series of credentials as it tries to update the website's server. But that
	// doesn't mean that it should dominate a different device that replaced it
	// only once, but later.
	NewlyShadowedCredentialIds [][]byte `protobuf:"bytes,5,rep,name=newly_shadowed_credential_ids,json=newlyShadowedCredentialIds" json:"newly_shadowed_credential_ids,omitempty"`
	// The local time on the device when this credential was created. Given in
	// milliseconds since the UNIX epoch. This is used to break ties between
	// credentials. See newly_shadowed_credential_ids.
	CreationTime *int64 `protobuf:"varint,6,opt,name=creation_time,json=creationTime" json:"creation_time,omitempty"`
	// The human-readable account identifier. Usually an email address.
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialentity-name
	UserName *string `protobuf:"bytes,7,opt,name=user_name,json=userName" json:"user_name,omitempty"`
	// The human-readable name. Usually a legal name. This is the only mutable
	// field in a credential.
	// https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialuserentity-displayname.
	UserDisplayName *string `protobuf:"bytes,8,opt,name=user_display_name,json=userDisplayName" json:"user_display_name,omitempty"`
	// The bytes of the private key, in a format known to the consumers of these
	// sync entities. In the future the private key may be encrypted with a
	// different key and then stored in a future encrypted_private_key field.
	PrivateKey           []byte   `protobuf:"bytes,9,opt,name=private_key,json=privateKey" json:"private_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WebauthnCredentialSpecifics) Reset()         { *m = WebauthnCredentialSpecifics{} }
func (m *WebauthnCredentialSpecifics) String() string { return proto.CompactTextString(m) }
func (*WebauthnCredentialSpecifics) ProtoMessage()    {}
func (*WebauthnCredentialSpecifics) Descriptor() ([]byte, []int) {
	return fileDescriptor_webauthn_credential_specifics_e8cca33aabade10e, []int{0}
}
func (m *WebauthnCredentialSpecifics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WebauthnCredentialSpecifics.Unmarshal(m, b)
}
func (m *WebauthnCredentialSpecifics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WebauthnCredentialSpecifics.Marshal(b, m, deterministic)
}
func (dst *WebauthnCredentialSpecifics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebauthnCredentialSpecifics.Merge(dst, src)
}
func (m *WebauthnCredentialSpecifics) XXX_Size() int {
	return xxx_messageInfo_WebauthnCredentialSpecifics.Size(m)
}
func (m *WebauthnCredentialSpecifics) XXX_DiscardUnknown() {
	xxx_messageInfo_WebauthnCredentialSpecifics.DiscardUnknown(m)
}

var xxx_messageInfo_WebauthnCredentialSpecifics proto.InternalMessageInfo

func (m *WebauthnCredentialSpecifics) GetSyncId() []byte {
	if m != nil {
		return m.SyncId
	}
	return nil
}

func (m *WebauthnCredentialSpecifics) GetCredentialId() []byte {
	if m != nil {
		return m.CredentialId
	}
	return nil
}

func (m *WebauthnCredentialSpecifics) GetRpId() string {
	if m != nil && m.RpId != nil {
		return *m.RpId
	}
	return ""
}

func (m *WebauthnCredentialSpecifics) GetUserId() []byte {
	if m != nil {
		return m.UserId
	}
	return nil
}

func (m *WebauthnCredentialSpecifics) GetNewlyShadowedCredentialIds() [][]byte {
	if m != nil {
		return m.NewlyShadowedCredentialIds
	}
	return nil
}

func (m *WebauthnCredentialSpecifics) GetCreationTime() int64 {
	if m != nil && m.CreationTime != nil {
		return *m.CreationTime
	}
	return 0
}

func (m *WebauthnCredentialSpecifics) GetUserName() string {
	if m != nil && m.UserName != nil {
		return *m.UserName
	}
	return ""
}

func (m *WebauthnCredentialSpecifics) GetUserDisplayName() string {
	if m != nil && m.UserDisplayName != nil {
		return *m.UserDisplayName
	}
	return ""
}

func (m *WebauthnCredentialSpecifics) GetPrivateKey() []byte {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func init() {
	proto.RegisterType((*WebauthnCredentialSpecifics)(nil), "sync_pb.WebauthnCredentialSpecifics")
}

func init() {
	proto.RegisterFile("components/sync/protocol/webauthn_credential_specifics.proto", fileDescriptor_webauthn_credential_specifics_e8cca33aabade10e)
}

var fileDescriptor_webauthn_credential_specifics_e8cca33aabade10e = []byte{
	// 317 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x54, 0x91, 0xdf, 0x4a, 0xc3, 0x30,
	0x14, 0xc6, 0xe9, 0xba, 0xbf, 0x71, 0x22, 0xd6, 0x0b, 0x8b, 0x43, 0x2c, 0x8a, 0x50, 0x14, 0xba,
	0x17, 0xf0, 0x46, 0xe7, 0x85, 0x45, 0x10, 0xd9, 0x04, 0x2f, 0x43, 0x96, 0x1c, 0x5d, 0xb0, 0xf9,
	0x43, 0x92, 0x39, 0xfa, 0xac, 0xbe, 0x8c, 0x24, 0xed, 0xdc, 0xbc, 0x3c, 0xdf, 0xf7, 0x3b, 0xe7,
	0x7c, 0xc9, 0x41, 0x77, 0x54, 0x09, 0xad, 0x24, 0x48, 0x67, 0xa7, 0xb6, 0x96, 0x74, 0xaa, 0x8d,
	0x72, 0x8a, 0xaa, 0x6a, 0xba, 0x81, 0x25, 0x59, 0xbb, 0x95, 0xc4, 0xd4, 0x00, 0x03, 0xe9, 0x38,
	0xa9, 0xb0, 0xd5, 0x40, 0xf9, 0x07, 0xa7, 0xb6, 0x08, 0x58, 0x32, 0xf0, 0x2d, 0x58, 0x2f, 0x2f,
	0x7f, 0x3a, 0x68, 0xf2, 0xde, 0x36, 0xcc, 0xfe, 0xf8, 0xc5, 0x16, 0x4f, 0x4e, 0x51, 0x83, 0x72,
	0x96, 0x46, 0x59, 0x94, 0x8f, 0xe7, 0x7d, 0x5f, 0x96, 0x2c, 0xb9, 0x42, 0x87, 0x7b, 0xf3, 0x39,
	0x4b, 0x3b, 0xc1, 0x1e, 0xef, 0xc4, 0x92, 0x25, 0x27, 0xa8, 0x67, 0xb4, 0x37, 0xe3, 0x2c, 0xca,
	0x47, 0xf3, 0xae, 0xd1, 0x25, 0xf3, 0x23, 0xd7, 0x16, 0x8c, 0x97, 0xbb, 0xcd, 0x48, 0x5f, 0x96,
	0x2c, 0xb9, 0x47, 0xe7, 0x12, 0x36, 0x55, 0x8d, 0xed, 0x8a, 0x30, 0xb5, 0x01, 0x86, 0xff, 0x6d,
	0xb0, 0x69, 0x2f, 0x8b, 0xf3, 0xf1, 0xfc, 0x2c, 0x40, 0x8b, 0x96, 0x99, 0xed, 0xed, 0xb3, 0x6d,
	0x2a, 0xe2, 0xb8, 0x92, 0xd8, 0x71, 0x01, 0x69, 0x3f, 0x8b, 0xf2, 0x38, 0xa4, 0x0a, 0xe2, 0x1b,
	0x17, 0x90, 0x4c, 0xd0, 0x28, 0x04, 0x90, 0x44, 0x40, 0x3a, 0x08, 0xc9, 0x86, 0x5e, 0x78, 0x21,
	0x02, 0x92, 0x1b, 0x74, 0x1c, 0x4c, 0xc6, 0xad, 0xae, 0x48, 0xdd, 0x40, 0xc3, 0x00, 0x1d, 0x79,
	0xe3, 0xb1, 0xd1, 0x03, 0x7b, 0x81, 0x0e, 0xb4, 0xe1, 0xdf, 0xc4, 0x01, 0xfe, 0x82, 0x3a, 0x1d,
	0x85, 0xd7, 0xa0, 0x56, 0x7a, 0x86, 0xfa, 0xe1, 0x16, 0x5d, 0x2b, 0xf3, 0x59, 0xd0, 0x95, 0x51,
	0x82, 0xaf, 0x45, 0xb1, 0xbb, 0x59, 0xe1, 0xbf, 0xb1, 0xd8, 0xde, 0xec, 0x29, 0x7e, 0x8d, 0x7e,
	0x03, 0x00, 0x00, 0xff, 0xff, 0x17, 0xa2, 0x58, 0x33, 0xd2, 0x01, 0x00, 0x00,
}
